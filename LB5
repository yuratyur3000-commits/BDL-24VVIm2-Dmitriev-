"""
Задание: Классификация изображений с Transfer Learning
Использование предобученной ResNet18
"""

import os
import torch
import torch.nn as nn
import torch.optim as optim
from torch.optim import lr_scheduler
import torchvision
from torchvision import datasets, models, transforms
import numpy as np
import matplotlib.pyplot as plt
import time
import copy
from PIL import Image

print("=" * 80)
print("КЛАССИФИКАЦИЯ ИЗОБРАЖЕНИЙ С RESNET18")
print("=" * 80)

# 1. ПУТИ К ДАННЫМ
print("\n1. НАСТРОЙКА ПУТЕЙ:")

# Папка с данными (ИЗМЕНЕНО: my_custom_dataset_505010)
base_data_dir = r'C:\Users\Юрий\Documents\ИТК\ПГУ\Магистрат\ВТ\2КУРС\Нейронные\my_custom_dataset_505010'

# Проверяем существование папки с данными
if not os.path.exists(base_data_dir):
    print(f"✗ Папка с данными не найдена: {base_data_dir}")
    print(f"Создайте папку my_custom_dataset_505010 со следующей структурой:")
    print(f"my_custom_dataset_505010/")
    print(f"  ├── train/")
    print(f"  │   ├── class1/")
    print(f"  │   ├── class2/")
    print(f"  │   └── ...")
    print(f"  ├── val/")
    print(f"  │   ├── class1/")
    print(f"  │   ├── class2/")
    print(f"  │   └── ...")
    print(f"  └── test/")
    print(f"      ├── class1/")
    print(f"      ├── class2/")
    print(f"      └── ...")
    exit(1)
else:
    print(f"✓ Папка с данными найдена: {base_data_dir}")

# Папка для сохранения результатов
results_dir = os.path.join(base_data_dir, 'results')
os.makedirs(results_dir, exist_ok=True)  # Создаем папку если она не существует
print(f"Папка для результатов: {results_dir}")

# Проверяем существование папок с данными
required_folders = ['train', 'val', 'test']
for folder in required_folders:
    folder_path = os.path.join(base_data_dir, folder)
    if not os.path.exists(folder_path):
        print(f"✗ Папка не найдена: {folder_path}")
        print(f"Создайте папку {folder} с подпапками классов внутри")
        print(f"Пример структуры:")
        print(f"{folder}/")
        print(f"├── cats/")
        print(f"├── dogs/")
        print(f"└── ...")
        exit(1)
    else:
        print(f"✓ Папка найдена: {folder_path}")
        
        # Проверяем наличие подпапок классов
        class_subfolders = [d for d in os.listdir(folder_path) 
                          if os.path.isdir(os.path.join(folder_path, d))]
        if len(class_subfolders) == 0:
            print(f"  ⚠ Внимание: Папка {folder} пуста или не содержит подпапок классов")
        else:
            print(f"  Найдено классов: {len(class_subfolders)}")
            print(f"  Классы: {class_subfolders}")

# 2. ЗАГРУЗКА И ПРЕОБРАЗОВАНИЕ ДАННЫХ
print("\n2. ЗАГРУЗКА ДАННЫХ:")

# Преобразования для изображений
data_transforms = {
    'train': transforms.Compose([
        transforms.RandomResizedCrop(224),
        transforms.RandomHorizontalFlip(),
        transforms.ToTensor(),
        transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])
    ]),
    'val': transforms.Compose([
        transforms.Resize(256),
        transforms.CenterCrop(224),
        transforms.ToTensor(),
        transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])
    ]),
    'test': transforms.Compose([
        transforms.Resize(256),
        transforms.CenterCrop(224),
        transforms.ToTensor(),
        transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])
    ]),
}

print("Загружаю датасеты...")

# Загружаем датасеты
image_datasets = {}
try:
    image_datasets['train'] = datasets.ImageFolder(
        os.path.join(base_data_dir, 'train'),
        data_transforms['train']
    )
    image_datasets['val'] = datasets.ImageFolder(
        os.path.join(base_data_dir, 'val'),
        data_transforms['val']
    )
    image_datasets['test'] = datasets.ImageFolder(
        os.path.join(base_data_dir, 'test'),
        data_transforms['test']
    )
    print("✓ Датасеты загружены успешно")
except Exception as e:
    print(f"✗ Ошибка загрузки датасетов: {e}")
    print("Проверьте структуру папок и наличие изображений")
    exit(1)

# Размеры датасетов и названия классов
dataset_sizes = {x: len(image_datasets[x]) for x in ['train', 'val', 'test']}
class_names = image_datasets['train'].classes

print(f"Классы: {class_names}")
print(f"Обучающих изображений: {dataset_sizes['train']}")
print(f"Валидационных изображений: {dataset_sizes['val']}")
print(f"Тестовых изображений: {dataset_sizes['test']}")

# 3. СОЗДАНИЕ DATALOADERS
print("\n3. СОЗДАНИЕ DATALOADERS:")

batch_size = 8
dataloaders = {
    x: torch.utils.data.DataLoader(
        image_datasets[x],
        batch_size=batch_size,
        shuffle=True if x == 'train' else False,
        num_workers=0
    )
    for x in ['train', 'val', 'test']
}

print(f"Размер пакета: {batch_size}")

# 4. ВИЗУАЛИЗАЦИЯ ДАННЫХ
print("\n4. ВИЗУАЛИЗАЦИЯ ДАННЫХ:")

def imshow(inp, title=None):
    """Показывает тензор как изображение"""
    inp = inp.numpy().transpose((1, 2, 0))
    mean = np.array([0.485, 0.456, 0.406])
    std = np.array([0.229, 0.224, 0.225])
    inp = std * inp + mean
    inp = np.clip(inp, 0, 1)
    plt.imshow(inp)
    if title is not None:
        plt.title(title)
    plt.axis('off')

# Показываем примеры изображений
try:
    inputs, classes = next(iter(dataloaders['train']))
    out = torchvision.utils.make_grid(inputs)
    
    plt.figure(figsize=(10, 5))
    imshow(out, title=[class_names[x] for x in classes])
    plt.tight_layout()
    sample_images_path = os.path.join(results_dir, 'sample_images.png')
    plt.savefig(sample_images_path, dpi=150)
    plt.show()
    print(f"✓ Примеры изображений показаны и сохранены в {sample_images_path}")
except Exception as e:
    print(f"Не удалось показать изображения: {e}")

# 5. ЗАГРУЗКА И НАСТРОЙКА RESNET18
print("\n5. НАСТРОЙКА RESNET18:")

print("Загружаю предобученную ResNet18...")
try:
    # Для более новых версий PyTorch используем weights
    try:
        # PyTorch 1.13+
        model = models.resnet18(weights=models.ResNet18_Weights.IMAGENET1K_V1)
        print("✓ ResNet18 загружена (новый метод)")
    except:
        # PyTorch старые версии
        model = models.resnet18(pretrained=True)
        print("✓ ResNet18 загружена (старый метод)")
except Exception as e:
    print(f"✗ Ошибка загрузки: {e}")
    print("Проверьте подключение к интернету")
    exit(1)

# Замораживаем все слои кроме последнего
for param in model.parameters():
    param.requires_grad = False

# Заменяем последний слой на наш
num_classes = len(class_names)
num_ftrs = model.fc.in_features
model.fc = nn.Linear(num_ftrs, num_classes)
print(f"Заменен последний слой на {num_classes} выходов")

# Перемещаем модель на устройство
device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")
model = model.to(device)
print(f"Устройство: {device}")

# 6. ОБУЧЕНИЕ МОДЕЛИ
print("\n6. ОБУЧЕНИЕ МОДЕЛИ:")

# Функция потерь и оптимизатор
criterion = nn.CrossEntropyLoss()
optimizer = optim.SGD(model.fc.parameters(), lr=0.001, momentum=0.9)
scheduler = lr_scheduler.StepLR(optimizer, step_size=5, gamma=0.1)

# Функция обучения
def train_model(model, criterion, optimizer, scheduler, num_epochs=5):
    since = time.time()
    best_model_wts = copy.deepcopy(model.state_dict())
    best_acc = 0.0
    
    train_losses, val_losses = [], []
    train_accs, val_accs = [], []
    
    for epoch in range(num_epochs):
        print(f'\nЭпоха {epoch+1}/{num_epochs}')
        print('-' * 40)
        
        for phase in ['train', 'val']:
            if phase == 'train':
                model.train()
            else:
                model.eval()
            
            running_loss = 0.0
            running_corrects = 0
            
            for inputs, labels in dataloaders[phase]:
                inputs = inputs.to(device)
                labels = labels.to(device)
                
                optimizer.zero_grad()
                
                with torch.set_grad_enabled(phase == 'train'):
                    outputs = model(inputs)
                    _, preds = torch.max(outputs, 1)
                    loss = criterion(outputs, labels)
                    
                    if phase == 'train':
                        loss.backward()
                        optimizer.step()
                
                running_loss += loss.item() * inputs.size(0)
                running_corrects += torch.sum(preds == labels.data)
            
            if phase == 'train':
                scheduler.step()
            
            epoch_loss = running_loss / dataset_sizes[phase]
            epoch_acc = running_corrects.double() / dataset_sizes[phase]
            
            if phase == 'train':
                train_losses.append(epoch_loss)
                train_accs.append(epoch_acc.item())
            else:
                val_losses.append(epoch_loss)
                val_accs.append(epoch_acc.item())
            
            print(f'{phase} Потеря: {epoch_loss:.4f}, Точность: {epoch_acc:.4f}')
            
            if phase == 'val' and epoch_acc > best_acc:
                best_acc = epoch_acc
                best_model_wts = copy.deepcopy(model.state_dict())
    
    time_elapsed = time.time() - since
    print(f'\nОбучение завершено за {time_elapsed // 60:.0f} мин {time_elapsed % 60:.0f} сек')
    print(f'Лучшая точность на валидации: {best_acc:.4f}')
    
    model.load_state_dict(best_model_wts)
    return model, train_losses, val_losses, train_accs, val_accs

# Запуск обучения
num_epochs = 5
print(f"Количество эпох: {num_epochs}")
print("Начинаю обучение...")

model, train_losses, val_losses, train_accs, val_accs = train_model(
    model, criterion, optimizer, scheduler, num_epochs=num_epochs
)

# 7. ВИЗУАЛИЗАЦИЯ РЕЗУЛЬТАТОВ
print("\n7. РЕЗУЛЬТАТЫ ОБУЧЕНИЯ:")

fig, axes = plt.subplots(1, 2, figsize=(12, 4))

# График потерь
axes[0].plot(range(1, len(train_losses) + 1), train_losses, 'b-', label='Обучающая')
axes[0].plot(range(1, len(val_losses) + 1), val_losses, 'r-', label='Валидационная')
axes[0].set_xlabel('Эпоха')
axes[0].set_ylabel('Потеря')
axes[0].set_title('Функция потерь')
axes[0].legend()
axes[0].grid(True, alpha=0.3)

# График точности
axes[1].plot(range(1, len(train_accs) + 1), train_accs, 'b-', label='Обучающая')
axes[1].plot(range(1, len(val_accs) + 1), val_accs, 'r-', label='Валидационная')
axes[1].set_xlabel('Эпоха')
axes[1].set_ylabel('Точность')
axes[1].set_title('Точность классификации')
axes[1].legend()
axes[1].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

# 8. ТЕСТИРОВАНИЕ МОДЕЛИ
print("\n8. ТЕСТИРОВАНИЕ НА ТЕСТОВЫХ ДАННЫХ:")

model.eval()
test_correct = 0
test_total = 0

with torch.no_grad():
    for inputs, labels in dataloaders['test']:
        inputs = inputs.to(device)
        labels = labels.to(device)
        
        outputs = model(inputs)
        _, predicted = torch.max(outputs, 1)
        
        test_total += labels.size(0)
        test_correct += (predicted == labels).sum().item()

test_accuracy = 100 * test_correct / test_total if test_total > 0 else 0
print(f"Точность на тестовых данных: {test_accuracy:.2f}%")
print(f"Правильно классифицировано: {test_correct}/{test_total}")

# 9. ДЕМОНСТРАЦИЯ РАБОТЫ МОДЕЛИ
print("\n9. ДЕМОНСТРАЦИЯ РАБОТЫ МОДЕЛИ:")

def show_predictions(model, num_images=6):
    model.eval()
    images_so_far = 0
    fig = plt.figure(figsize=(12, 8))
    
    with torch.no_grad():
        for inputs, labels in dataloaders['test']:
            inputs = inputs.to(device)
            labels = labels.to(device)
            
            outputs = model(inputs)
            _, preds = torch.max(outputs, 1)
            
            for j in range(inputs.size()[0]):
                images_so_far += 1
                ax = plt.subplot(2, 3, images_so_far)
                ax.axis('off')
                
                img = inputs.cpu().data[j]
                imshow(img)
                
                true_label = class_names[labels[j]]
                pred_label = class_names[preds[j]]
                
                color = 'green' if preds[j] == labels[j] else 'red'
                ax.set_title(f'Истинный: {true_label}\nПредсказано: {pred_label}', color=color)
                
                if images_so_far == num_images:
                    plt.suptitle('Примеры классификации', fontsize=14)
                    plt.tight_layout()
                    plt.show()
                    return
    
    plt.suptitle('Примеры классификации', fontsize=14)
    plt.tight_layout()
    plt.show()

show_predictions(model)

# 10. СОХРАНЕНИЕ МОДЕЛИ И РЕЗУЛЬТАТОВ
print("\n10. СОХРАНЕНИЕ РЕЗУЛЬТАТОВ:")

# Убедимся, что папка results существует
if not os.path.exists(results_dir):
    os.makedirs(results_dir, exist_ok=True)
    print(f"Создана папка: {results_dir}")

# Сохраняем модель
model_path = os.path.join(results_dir, 'resnet18_model.pth')
try:
    torch.save({
        'model_state_dict': model.state_dict(),
        'class_names': class_names,
        'accuracy': test_accuracy,
        'epochs': num_epochs
    }, model_path)
    print(f"✓ Модель сохранена: {model_path}")
except Exception as e:
    print(f"✗ Ошибка сохранения модели: {e}")

# Сохраняем графики обучения
graph_path = os.path.join(results_dir, 'training_results.png')
try:
    fig, axes = plt.subplots(1, 2, figsize=(12, 4))
    
    axes[0].plot(range(1, len(train_losses) + 1), train_losses, 'b-', label='Обучающая')
    axes[0].plot(range(1, len(val_losses) + 1), val_losses, 'r-', label='Валидационная')
    axes[0].set_xlabel('Эпоха')
    axes[0].set_ylabel('Потеря')
    axes[0].set_title('Функция потерь')
    axes[0].legend()
    axes[0].grid(True, alpha=0.3)
    
    axes[1].plot(range(1, len(train_accs) + 1), train_accs, 'b-', label='Обучающая')
    axes[1].plot(range(1, len(val_accs) + 1), val_accs, 'r-', label='Валидационная')
    axes[1].set_xlabel('Эпоха')
    axes[1].set_ylabel('Точность')
    axes[1].set_title('Точность классификации')
    axes[1].legend()
    axes[1].grid(True, alpha=0.3)
    
    plt.suptitle(f'Результаты обучения ResNet18 (Точность: {test_accuracy:.2f}%)', fontsize=14)
    plt.tight_layout()
    plt.savefig(graph_path, dpi=150)
    plt.close()
    print(f"✓ Графики сохранены: {graph_path}")
except Exception as e:
    print(f"✗ Ошибка сохранения графиков: {e}")

# Сохраняем информацию о модели в текстовый файл
info_path = os.path.join(results_dir, 'model_info.txt')
try:
    with open(info_path, 'w', encoding='utf-8') as f:
        f.write("РЕЗУЛЬТАТЫ ОБУЧЕНИЯ RESNET18\n")
        f.write("=" * 40 + "\n\n")
        f.write(f"Дата обучения: {time.strftime('%Y-%m-%d %H:%M:%S')}\n")
        f.write(f"Путь к данным: {base_data_dir}\n")
        f.write(f"Количество классов: {len(class_names)}\n")
        f.write(f"Классы: {', '.join(class_names)}\n\n")
        f.write(f"Размер обучающей выборки: {dataset_sizes['train']}\n")
        f.write(f"Размер валидационной выборки: {dataset_sizes['val']}\n")
        f.write(f"Размер тестовой выборки: {dataset_sizes['test']}\n\n")
        f.write(f"Количество эпох: {num_epochs}\n")
        f.write(f"Размер пакета: {batch_size}\n")
        f.write(f"Лучшая точность на валидации: {best_acc:.4f}\n")
        f.write(f"Точность на тестовых данных: {test_accuracy:.2f}%\n")
        f.write(f"Правильно классифицировано: {test_correct}/{test_total}\n\n")
        f.write("ПАРАМЕТРЫ МОДЕЛИ:\n")
        f.write(f"Устройство: {device}\n")
        f.write(f"Learning rate: 0.001\n")
        f.write(f"Momentum: 0.9\n")
        f.write(f"Scheduler: StepLR (step_size=5, gamma=0.1)\n")
    print(f"✓ Информация о модели сохранена: {info_path}")
except Exception as e:
    print(f"✗ Ошибка сохранения информации: {e}")

print("\n" + "=" * 80)
print("ОБУЧЕНИЕ ЗАВЕРШЕНО УСПЕШНО!")
print("=" * 80)
print(f"Модель: ResNet18")
print(f"Путь к данным: {base_data_dir}")
print(f"Классы: {class_names}")
print(f"Точность: {test_accuracy:.2f}%")
print(f"Результаты сохранены в: {results_dir}")
print("=" * 80)
